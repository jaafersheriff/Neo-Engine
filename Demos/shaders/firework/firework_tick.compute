

layout(std140, binding = 0) coherent buffer BufferA {
	vec4 posIntensity[];
};

layout(std140, binding = 1) coherent buffer BufferB {
	vec4 velocity[];
};


uniform vec3 lightPos;
uniform float timestep;

float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

void init() {
	float speed = 2.0;
	float vel =   speed * (rand(1.19827 + gl_GlobalInvocationID.yx + timestep) * 2.0 - 1.0);
	float theta = rand(timestep * 2.78631 + gl_GlobalInvocationID.xy + timestep) * 2.0 - 1.0;
	float phi =   rand(timestep * 3.52049 + gl_GlobalInvocationID.xx + timestep) * 2.0 - 1.0;
	float x = vel * sin(phi) * sin(theta);
	float z = vel * sin(phi) * cos(theta);
	float y = vel * cos(phi);
	vec3 v = vec3(x, -abs(y), z);

	velocity[gl_GlobalInvocationID.x] = vec4(v, 0.0);
	float offset = 0.1;
	posIntensity[gl_GlobalInvocationID.x].rgb = lightPos;
	posIntensity[gl_GlobalInvocationID.x].a = rand(gl_GlobalInvocationID.xx + timestep);

	 if (gl_GlobalInvocationID.x % 16 == 0.0) {
	 	posIntensity[gl_GlobalInvocationID.x].a *= 2.0;
		velocity[gl_GlobalInvocationID.x].a = 1.0;
	 }
	 else {
	 	posIntensity[gl_GlobalInvocationID.x].xyz = posIntensity[gl_GlobalInvocationID.x - (gl_GlobalInvocationID.x % 16)].xyz;
	 	posIntensity[gl_GlobalInvocationID.x].a *= 0.7;
		velocity[gl_GlobalInvocationID.x].a = 0.0;
		velocity[gl_GlobalInvocationID.x].y = -abs(velocity[gl_GlobalInvocationID.x].y);
	 }
}

layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;
void main() {
#ifdef INIT
	init();
	return;
#endif
	float intensity = posIntensity[gl_GlobalInvocationID.x].a;
	if (intensity < 0.15) {
		init();
		return;
	}
	vec3 pos = posIntensity[gl_GlobalInvocationID.x].xyz;
	vec4 vel = velocity[gl_GlobalInvocationID.x];
	vel.xyz += vec3(0, -0.98 * timestep, 0);
	pos += vel.xyz * timestep;

	if (vel.a > 0.9) {
		intensity *= 0.99; // TODO uniform
	}
	else {
		intensity *= 0.97; // TODO uniform
	}

	posIntensity[gl_GlobalInvocationID.x] = vec4(pos, intensity);
	velocity[gl_GlobalInvocationID.x] = vel;
}
